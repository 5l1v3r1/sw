#include "commands.h"
#include "inserts.h"

#include <primitives/emitter.h>
#include <sw/driver/build.h>
#include <sw/driver/sw_context.h>
#include <sw/driver/target/native.h>

static ::cl::opt<path> integrate_cmake_deps("cmake-deps", ::cl::sub(subcommand_integrate));
static ::cl::opt<path> integrate_waf_deps("waf-deps", ::cl::sub(subcommand_integrate));

struct CMakeEmitter : primitives::Emitter
{
    void if_(const String &s)
    {
        addLine("if (" + s + ")");
        increaseIndent();
    }

    void elseif(const String &s)
    {
        decreaseIndent();
        emptyLines(0);
        addLine("elseif(" + s + ")");
        increaseIndent();
    }

    void else_()
    {
        decreaseIndent();
        emptyLines(0);
        addLine("else()");
        increaseIndent();
    }

    void endif()
    {
        decreaseIndent();
        emptyLines(0);
        addLine("endif()");
        emptyLines();
    }
};

static String toCmakeString(sw::ConfigurationType t)
{
    switch (t)
    {
    case sw::ConfigurationType::Debug: return "DEBUG";
    case sw::ConfigurationType::MinimalSizeRelease: return "MINSIZEREL";
    case sw::ConfigurationType::ReleaseWithDebugInformation: return "RELWITHDEBINFO";
    case sw::ConfigurationType::Release: return "RELEASE";
    default:
        SW_UNIMPLEMENTED;
    }
}

SUBCOMMAND_DECL(integrate)
{
    if (!integrate_cmake_deps.empty())
    {
        auto lines = read_lines(integrate_cmake_deps);

        auto swctx = createSwContext();
        sw::Build b(swctx);
        b.Local = false;
        for (auto &cfg : {
            sw::ConfigurationType::Debug,
            sw::ConfigurationType::MinimalSizeRelease,
            sw::ConfigurationType::ReleaseWithDebugInformation,
            sw::ConfigurationType::Release,
            })
        {
            auto ss = b.createSettings();
            ss.Native.ConfigurationType = cfg;
            b.addSettings(ss);
        }
        b.load_packages(StringSet(lines.begin(), lines.end()));
        b.prepare(); // or step?

        CMakeEmitter ctx;
        ctx.addLine("#");
        ctx.addLine("# sw autogenerated file");
        ctx.addLine("#");
        ctx.emptyLines();

        // targets
        ctx.addLine("# targets");
        for (auto &s : b.settings)
        {
            for (auto &[pkg, td] : b.getChildren())
            {
                if (td.find(sw::TargetSettings{ s }) == td.end())
                    throw SW_RUNTIME_ERROR(pkg.toString() + ": missing config: " + s.getConfig());
                auto t = td.find(sw::TargetSettings{ s })->second;
                if (t->skip || t->sw_provided)
                    continue;
                auto &nt = *t->as<sw::NativeCompiledTarget>();
                if (t->getType() == sw::TargetType::NativeExecutable)
                    continue;

                ctx.if_("NOT TARGET " + pkg.toString());

                // tgt
                auto st = "STATIC";
                if (t->getType() == sw::TargetType::NativeStaticLibrary)
                    ;
                else if (
                    t->getType() == sw::TargetType::NativeSharedLibrary ||
                    s.Native.LibrariesType == sw::LibraryType::Shared)
                    st = "SHARED";
                if (*nt.HeaderOnly)
                    st = "INTERFACE";
                ctx.addLine("add_library(" + pkg.toString() + " " + st + " IMPORTED GLOBAL)");

                // props
                ctx.increaseIndent("set_target_properties(" + pkg.toString() + " PROPERTIES");

                // defs
                String defs;
                defs += "\"";
                for (auto &[k,v] : nt.Public.Definitions)
                {
                    if (v.empty())
                        defs += k + ";";
                    else
                        defs += k + "=" + primitives::command::Argument::quote(v.toString(), primitives::command::QuoteType::Escape) + ";";
                }
                for (auto &[k,v] : nt.Interface.Definitions)
                {
                    if (v.empty())
                        defs += k + ";";
                    else
                        defs += k + "=" + primitives::command::Argument::quote(v.toString(), primitives::command::QuoteType::Escape) + ";";
                }
                defs += "\"";
                ctx.addLine("INTERFACE_COMPILE_DEFINITIONS " + defs);

                // idirs
                String idirs;
                idirs += "\"";
                for (auto &d : nt.Public.IncludeDirectories)
                    idirs += normalize_path(d) + ";";
                for (auto &d : nt.Interface.IncludeDirectories)
                    idirs += normalize_path(d) + ";";
                idirs += "\"";
                ctx.addLine("INTERFACE_INCLUDE_DIRECTORIES " + idirs);

                if (!*nt.HeaderOnly)
                {
                    // libs
                    String libs;
                    libs += "\"";
                    for (auto &d : nt.Public.LinkLibraries2)
                        libs += normalize_path(d) + ";";
                    for (auto &d : nt.Interface.LinkLibraries2)
                        libs += normalize_path(d) + ";";
                    libs += "\"";
                    ctx.addLine("INTERFACE_LINK_LIBRARIES " + libs);
                }

                ctx.decreaseIndent(")");
                ctx.emptyLines();
                //

                // imported configs
                for (auto &s : b.settings)
                {
                    auto t = b.getChildren().find(pkg)->second.find(sw::TargetSettings{ s })->second;
                    if (t->skip || t->sw_provided)
                        continue;
                    if (*nt.HeaderOnly)
                        continue;
                    auto &nt = *t->as<sw::NativeCompiledTarget>();

                    ctx.addLine("set_property(TARGET " + pkg.toString() + " APPEND PROPERTY IMPORTED_CONFIGURATIONS " + toCmakeString(s.Native.ConfigurationType) + ")");

                    // props2
                    ctx.increaseIndent("set_target_properties(" + pkg.toString() + " PROPERTIES");

                    // TODO: detect C/CXX language from target files
                    ctx.addLine("IMPORTED_LINK_INTERFACE_LANGUAGES_" + toCmakeString(s.Native.ConfigurationType) + " \"CXX\"");

                    // IMPORTED_LOCATION = path to .dll/.so or static .lib/.a
                    ctx.addLine("IMPORTED_LOCATION_" + toCmakeString(s.Native.ConfigurationType) + " \"" + normalize_path(nt.getOutputFile()) + "\"");
                    // IMPORTED_IMPLIB = path to .lib (import)
                    ctx.addLine("IMPORTED_IMPLIB_" + toCmakeString(s.Native.ConfigurationType) + " \"" + normalize_path(nt.getImportLibrary()) + "\"");

                    ctx.decreaseIndent(")");
                    ctx.emptyLines();
                }
                //

                ctx.emptyLines();

                // build dep
                ctx.addLine("add_dependencies(" + pkg.toString() + " sw_build_dependencies)");
                ctx.emptyLines();

                if (pkg.version.isVersion())
                for (auto i = pkg.version.getLevel() - 1; i >= 0; i--)
                {
                    if (i)
                        ctx.addLine("add_library(" + pkg.ppath.toString() + "-" + pkg.version.toString(i) + " ALIAS " + pkg.toString() + ")");
                    else
                        ctx.addLine("add_library(" + pkg.ppath.toString() + " ALIAS " + pkg.toString() + ")");
                }

                ctx.endif();
            }
            break;
        }

        // deps
        ctx.addLine("# dependencies");
        for (auto &s : b.settings)
        {
            for (auto &[pkg, td] : b.getChildren())
            {
                if (td.find(sw::TargetSettings{ s }) == td.end())
                    throw SW_RUNTIME_ERROR(pkg.toString() + ": missing config: " + s.getConfig());
                auto t = td.find(sw::TargetSettings{ s })->second;
                if (t->skip || t->sw_provided)
                    continue;
                auto &nt = *t->as<sw::NativeCompiledTarget>();
                if (t->getType() == sw::TargetType::NativeExecutable)
                    continue;

                auto add_deps = [&ctx, &b, &pkg, &s](auto &deps)
                {
                    for (auto &d : deps)
                    {
                        if (d->isDummy())
                            continue;
                        auto t = b.getChildren().find(d->getResolvedPackage())->second.find(sw::TargetSettings{ s })->second;
                        if (t->skip || t->sw_provided)
                            continue;
                        if (!t->as<sw::ExecutableTarget>())
                            ctx.addLine("target_link_libraries(" + pkg.toString() + " INTERFACE " + d->getResolvedPackage().toString() + ")");
                    }
                };
                add_deps(nt.Public.Dependencies);
                add_deps(nt.Interface.Dependencies);
            }
            break;
        }
        write_file_if_different(integrate_cmake_deps.parent_path() / "CMakeLists.txt", ctx.getText());

        return;
    }

    if (!integrate_waf_deps.empty())
    {
        auto lines = read_lines(integrate_waf_deps);

        auto swctx = createSwContext();
        sw::Build b(swctx);
        b.Local = false;
        b.load_packages(StringSet(lines.begin(), lines.end()));
        b.prepare(); // or step?

        // https://waf.io/apidocs/_modules/waflib/Tools/c_config.html#parse_flags
        primitives::Emitter ctx;

        ctx.increaseIndent("def configure(ctx):");

        for (auto &s : b.settings)
        {
            for (auto &[pkg, td] : b.getChildren())
            {
                if (td.find(sw::TargetSettings{ s }) == td.end())
                    throw SW_RUNTIME_ERROR(pkg.toString() + ": missing config: " + s.getConfig());
                auto t = td.find(sw::TargetSettings{ s })->second;
                if (t->skip || t->sw_provided)
                    continue;
                auto &nt = *t->as<sw::NativeCompiledTarget>();
                if (t->getType() == sw::TargetType::NativeExecutable)
                    continue;

                ctx.addLine("# " + pkg.toString());
                ctx.increaseIndent("for lib in [");
                for (auto i = pkg.version.getLevel(); i >= 0; i--)
                {
                    if (i)
                        ctx.addLine("'" + pkg.ppath.toString() + "-" + pkg.version.toString(i) + "',");
                    else
                        ctx.addLine("'" + pkg.ppath.toString() + "',");
                }
                ctx.decreaseIndent("]:");
                ctx.increaseIndent();

                auto remove_ext = [](const auto &p)
                {
                    return p.parent_path() / p.stem();
                };

                ctx.addLine("ctx.parse_flags('-l" + normalize_path(remove_ext(nt.getImportLibrary())) + "', lib)");

                std::function<void(sw::NativeCompiledTarget&)> process;
                std::unordered_set<sw::NativeCompiledTarget *> visited;
                process = [&process, &s, &b, &ctx, &remove_ext, &visited](auto &nt)
                {
                    if (visited.find(&nt) != visited.end())
                        return;
                    visited.insert(&nt);

                    // defs
                    for (auto &[k,v] : nt.Public.Definitions)
                    {
                        if (v.empty())
                            ctx.addLine("ctx.parse_flags('-D" + k + "', lib)");
                        else
                            ctx.addLine("ctx.parse_flags('-D" + k + "=" + primitives::command::Argument::quote(v.toString(), primitives::command::QuoteType::Escape) + "', lib)");
                    }
                    for (auto &[k,v] : nt.Interface.Definitions)
                    {
                        if (v.empty())
                            ctx.addLine("ctx.parse_flags('-D" + k + "', lib)");
                        else
                            ctx.addLine("ctx.parse_flags('-D" + k + "=" + primitives::command::Argument::quote(v.toString(), primitives::command::QuoteType::Escape) + "', lib)");
                    }

                    // idirs
                    for (auto &d : nt.Public.IncludeDirectories)
                        ctx.addLine("ctx.parse_flags('-I" + normalize_path(d) + "', lib)");
                    for (auto &d : nt.Interface.IncludeDirectories)
                        ctx.addLine("ctx.parse_flags('-I" + normalize_path(d) + "', lib)");

                    // libs
                    for (auto &d : nt.Public.LinkLibraries2)
                        ctx.addLine("ctx.parse_flags('-l" + normalize_path(remove_ext(d)) + "', lib)");
                    for (auto &d : nt.Interface.LinkLibraries2)
                        ctx.addLine("ctx.parse_flags('-l" + normalize_path(remove_ext(d)) + "', lib)");

                    // deps
                    auto add_deps = [&ctx, &b, &s, &process, &remove_ext](auto &deps)
                    {
                        for (auto &d : deps)
                        {
                            auto t = b.getChildren().find(d->getResolvedPackage())->second.find(sw::TargetSettings{ s })->second;
                            if (t->skip || t->sw_provided)
                                continue;
                            if (t->getType() == sw::TargetType::NativeExecutable)
                                continue;

                            auto &nt = *t->as<sw::NativeCompiledTarget>();
                            ctx.addLine("ctx.parse_flags('-l" + normalize_path(remove_ext(nt.getImportLibrary())) + "', lib)");

                            process(nt);
                        }
                    };
                    add_deps(nt.Public.Dependencies);
                    add_deps(nt.Interface.Dependencies);
                };
                process(nt);

                ctx.decreaseIndent();
                ctx.emptyLines();
                //
            }
            break;
        }

        write_file_if_different("wscript", ctx.getText());

        return;
    }

    SW_UNIMPLEMENTED;
}
