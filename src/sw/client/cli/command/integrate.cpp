/*
 * SW - Build System and Package Manager
 * Copyright (C) 2017-2019 Egor Pugin
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "commands.h"
#include "../inserts.h"

#include <boost/algorithm/string.hpp>
#include <primitives/emitter.h>
#include <sw/core/input.h>
#include <sw/core/sw_context.h>
#include <sw/driver/build_settings.h>
#include <sw/driver/types.h>

DEFINE_SUBCOMMAND(integrate, "Integrate sw into different tools.");

static ::cl::opt<path> integrate_cmake_deps("cmake-deps", ::cl::sub(subcommand_integrate));
static ::cl::opt<path> integrate_waf_deps("waf-deps", ::cl::sub(subcommand_integrate));

struct CMakeEmitter : primitives::Emitter
{
    void if_(const String &s)
    {
        addLine("if (" + s + ")");
        increaseIndent();
    }

    void elseif(const String &s)
    {
        decreaseIndent();
        emptyLines(0);
        addLine("elseif(" + s + ")");
        increaseIndent();
    }

    void else_()
    {
        decreaseIndent();
        emptyLines(0);
        addLine("else()");
        increaseIndent();
    }

    void endif()
    {
        decreaseIndent();
        emptyLines(0);
        addLine("endif()");
        emptyLines();
    }
};

static String toCmakeString(sw::ConfigurationType t)
{
    switch (t)
    {
    case sw::ConfigurationType::Debug: return "DEBUG";
    case sw::ConfigurationType::MinimalSizeRelease: return "MINSIZEREL";
    case sw::ConfigurationType::ReleaseWithDebugInformation: return "RELWITHDEBINFO";
    case sw::ConfigurationType::Release: return "RELEASE";
    default:
        SW_UNIMPLEMENTED;
    }
}

SUBCOMMAND_DECL(integrate)
{
    auto swctx = createSwContext();

    auto create_build = [&swctx](const Strings &lines, const Strings &configs = {})
    {
        auto build = createBuild(*swctx);
        auto &b = *build;

        auto settings = createSettings(*swctx);
        if (settings.size() > 1)
            throw SW_RUNTIME_ERROR("size() must be 1");
        for (auto &l : lines)
        {
            auto &i = swctx->addInput(l);
            sw::InputWithSettings s(i);
            if (!configs.empty())
            {
                for (String cfg : configs)
                {
                    auto cfgl = boost::to_lower_copy(cfg);
                    settings[0]["native"]["configuration"] = cfgl;
                    s.addSettings(settings[0]);
                }
            }
            else
            {
                s.addSettings(settings[0]);
            }
            b.addInput(s);
        }
        b.loadInputs();
        b.setTargetsToBuild();
        b.resolvePackages();
        b.loadPackages();
        b.prepare();

        return build;
    };

    if (!integrate_cmake_deps.empty())
    {
        const Strings configs
        {
            "Debug",
            "MinimalSizeRelease",
            "ReleaseWithDebugInformation",
            "Release",
        };

        auto lines = read_lines(integrate_cmake_deps);
        auto build = create_build(lines, configs);
        auto &b = *build;

        CMakeEmitter ctx;
        ctx.addLine("#");
        ctx.addLine("# sw autogenerated file");
        ctx.addLine("#");
        ctx.emptyLines();

        // targets
        ctx.addLine("# targets");
        for (auto &[pkg, tgts] : b.getTargets())
        {
            if (tgts.empty())
            {
                continue;
                //throw SW_RUNTIME_ERROR("No targets in " + pkg.toString());
            }
            // filter out predefined targets
            if (b.getContext().getPredefinedTargets().find(pkg) != b.getContext().getPredefinedTargets().end())
                continue;

            auto &t = **tgts.begin();
            const auto &s = t.getInterfaceSettings();

            if (s["type"] == "native_executable")
                continue;

            ctx.if_("NOT TARGET " + pkg.toString());

            // tgt
            auto st = "STATIC";
            if (s["type"] == "native_static_library")
                ;
            else if (s["type"] == "native_shared_library")
                st = "SHARED";
            if (s["header_only"] == "true")
                st = "INTERFACE";
            ctx.addLine("add_library(" + pkg.toString() + " " + st + " IMPORTED GLOBAL)");

            // props
            ctx.increaseIndent("set_target_properties(" + pkg.toString() + " PROPERTIES");

            // defs
            String defs;
            defs += "\"";
            for (auto &[k,v] : s["definitions"].getSettings())
            {
                if (v.getValue().empty())
                    defs += k + ";";
                else
                    defs += k + "=" + primitives::command::Argument::quote(v.getValue(), primitives::command::QuoteType::Escape) + ";";
            }
            defs += "\"";
            ctx.addLine("INTERFACE_COMPILE_DEFINITIONS " + defs);

            // idirs
            String idirs;
            idirs += "\"";
            for (auto &d : s["include_directories"].getArray())
                idirs += d + ";";
            idirs += "\"";
            ctx.addLine("INTERFACE_INCLUDE_DIRECTORIES " + idirs);

            if (s["header_only"] != "true")
            {
                // libs
                String libs;
                libs += "\"";
                for (auto &d : s["link_libraries"].getArray())
                    libs += d + ";";
                for (auto &d : s["system_link_libraries"].getArray())
                    libs += d + ";";
                libs += "\"";
                ctx.addLine("INTERFACE_LINK_LIBRARIES " + libs);
            }

            ctx.decreaseIndent(")");
            ctx.emptyLines();
            //

            // imported configs
            for (auto &tgt : tgts)
            {
                const auto &s = tgt->getInterfaceSettings();
                if (s["header_only"] == "true")
                    continue;

                sw::BuildSettings bs(tgt->getSettings());

                ctx.addLine("set_property(TARGET " + pkg.toString() + " APPEND PROPERTY IMPORTED_CONFIGURATIONS " + toCmakeString(bs.Native.ConfigurationType) + ")");

                // props2
                ctx.increaseIndent("set_target_properties(" + pkg.toString() + " PROPERTIES");

                // TODO: detect C/CXX language from target files
                ctx.addLine("IMPORTED_LINK_INTERFACE_LANGUAGES_" + toCmakeString(bs.Native.ConfigurationType) + " \"CXX\"");

                // IMPORTED_LOCATION = path to .dll/.so or static .lib/.a
                ctx.addLine("IMPORTED_LOCATION_" + toCmakeString(bs.Native.ConfigurationType) + " \"" +
                    normalize_path(s[st == "SHARED" ? "output_file" : "import_library"].getValue()) + "\"");
                // IMPORTED_IMPLIB = path to .lib (import)
                ctx.addLine("IMPORTED_IMPLIB_" + toCmakeString(bs.Native.ConfigurationType) + " \"" +
                    normalize_path(s["import_library"].getValue()) + "\"");

                ctx.decreaseIndent(")");
                ctx.emptyLines();
            }
            //

            ctx.emptyLines();

            // build dep
            ctx.addLine("add_dependencies(" + pkg.toString() + " sw_build_dependencies)");
            ctx.emptyLines();

            if (pkg.getVersion().isVersion())
            {
                for (auto i = pkg.getVersion().getLevel() - 1; i >= 0; i--)
                {
                    if (i)
                        ctx.addLine("add_library(" + pkg.getPath().toString() + "-" + pkg.getVersion().toString(i) + " ALIAS " + pkg.toString() + ")");
                    else
                        ctx.addLine("add_library(" + pkg.getPath().toString() + " ALIAS " + pkg.toString() + ")");
                }
            }

            ctx.endif();
        }

        // deps
        ctx.addLine("# dependencies");
        for (auto &[pkg, tgts] : b.getTargets())
        {
            if (tgts.empty())
            {
                continue;
                //throw SW_RUNTIME_ERROR("No targets in " + pkg.toString());
            }
            // filter out predefined targets
            if (b.getContext().getPredefinedTargets().find(pkg) != b.getContext().getPredefinedTargets().end())
                continue;

            auto &t = **tgts.begin();
            const auto &s = t.getInterfaceSettings();

            if (s["type"] == "native_executable")
                continue;

            for (auto &[k,v] : s["dependencies"]["link"].getSettings())
                ctx.addLine("target_link_libraries(" + pkg.toString() + " INTERFACE " + k + ")");
        }
        write_file_if_different(integrate_cmake_deps.parent_path() / "CMakeLists.txt", ctx.getText());

        return;
    }

    if (!integrate_waf_deps.empty())
    {
        auto lines = read_lines(integrate_waf_deps);
        auto build = create_build(lines);
        auto &b = *build;

        // https://waf.io/apidocs/_modules/waflib/Tools/c_config.html#parse_flags
        primitives::Emitter ctx;

        ctx.increaseIndent("def configure(ctx):");

        for (auto &[pkg, tgts] : b.getTargets())
        {
            if (tgts.empty())
            {
                continue;
                //throw SW_RUNTIME_ERROR("No targets in " + pkg.toString());
            }
            // filter out predefined targets
            if (b.getContext().getPredefinedTargets().find(pkg) != b.getContext().getPredefinedTargets().end())
                continue;

            auto &t = **tgts.begin();
            const auto &s = t.getInterfaceSettings();

            if (s["type"] == "native_executable")
                continue;

            ctx.addLine("# " + pkg.toString());
            ctx.increaseIndent("for lib in [");
            for (auto i = pkg.getVersion().getLevel(); i >= 0; i--)
            {
                if (i)
                    ctx.addLine("'" + pkg.getPath().toString() + "-" + pkg.getVersion().toString(i) + "',");
                else
                    ctx.addLine("'" + pkg.getPath().toString() + "',");
            }
            ctx.decreaseIndent("]:");
            ctx.increaseIndent();

            using tgt_type = std::pair<sw::PackageId, sw::TargetSettings>;
            using f_param = const tgt_type &;
            std::function<void(f_param)> process;
            std::set<tgt_type> visited;
            process = [&process, &s, &b, &ctx, &visited](f_param nt)
            {
                if (visited.find(nt) != visited.end())
                    return;
                visited.insert(nt);

                auto t = b.getTargets().find(nt.first, nt.second);
                if (!t)
                    throw SW_RUNTIME_ERROR("no such target: " + nt.first.toString());

                const auto &s = t->getInterfaceSettings();

                auto remove_ext = [](const path &p)
                {
                    return p.parent_path() / p.stem();
                };

                ctx.addLine("ctx.parse_flags('-l" + normalize_path(remove_ext(s["import_library"].getValue())) + "', lib)");

                // defs
                for (auto &[k,v] : s["definitions"].getSettings())
                {
                    if (v.getValue().empty())
                        ctx.addLine("ctx.parse_flags('-D" + k + "', lib)");
                    else
                        ctx.addLine("ctx.parse_flags('-D" + k + "=" + primitives::command::Argument::quote(v.getValue(), primitives::command::QuoteType::Escape) + "', lib)");
                }

                // idirs
                for (auto &d : s["include_directories"].getArray())
                    ctx.addLine("ctx.parse_flags('-I" + normalize_path(d) + "', lib)");

                // libs
                for (auto &d : s["link_libraries"].getArray())
                    ctx.addLine("ctx.parse_flags('-l" + normalize_path(remove_ext(d)) + "', lib)");
                for (auto &d : s["system_link_libraries"].getArray())
                    ctx.addLine("ctx.parse_flags('-l" + normalize_path(remove_ext(d)) + "', lib)");

                // deps
                for (auto &[k,v] : s["dependencies"]["link"].getSettings())
                {
                    process({k, v.getSettings()});
                }
            };
            process({t.getPackage(), t.getSettings()});

            ctx.decreaseIndent();
            ctx.emptyLines();
            //
        }

        write_file_if_different("wscript", ctx.getText());

        return;
    }

    SW_UNIMPLEMENTED;
}
